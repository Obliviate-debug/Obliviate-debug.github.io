<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2023/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>位，字节，字：</p><p><strong>解释：</strong></p><p>位&#x3D;比特&#x3D;bit   ： 信息的最小单位，等于0或1</p><p>字节 &#x3D; byte    ：可以表示一个英文字母，数字或者符号</p><p>字 &#x3D; word ： <u>描述计算机一次性处理事务的固定长度</u></p><p><strong>说明：</strong></p><p>1 byte &#x3D; 8 bit   大小相当于2^8 &#x3D;256</p><p><u>在说字长和字之前，需要说明在多少位操作系统的环境下</u></p><p>1 word &#x3D; 16 bit[16位操作系统下]</p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><h3 id="移码表示"><a href="#移码表示" class="headerlink" title="移码表示"></a>移码表示</h3><p>通常用于表示浮点数的阶码</p><p>移码和补码的符号位相反</p><p><strong>表示的范围</strong>：8位移码 00000000-11111111</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>1.可以直观的判断两个数据大小</p><p>2.阶码全为0时，浮点数下溢</p><p><img src="image1.png" alt="image1"></p><h3 id="浮点数表示："><a href="#浮点数表示：" class="headerlink" title="浮点数表示："></a>浮点数表示：</h3><p>一般表示形式</p><p><img src="image2.png" alt="image2"></p><h1 id="第五章CPU"><a href="#第五章CPU" class="headerlink" title="第五章CPU"></a>第五章CPU</h1><p><img src="image3.png" alt="image3"></p><h2 id="5-1CPU的功能和组成"><a href="#5-1CPU的功能和组成" class="headerlink" title="5.1CPU的功能和组成"></a>5.1CPU的功能和组成</h2><h3 id="主要寄存器"><a href="#主要寄存器" class="headerlink" title="主要寄存器"></a>主要寄存器</h3><h4 id="1-DR（数据缓冲寄存器）"><a href="#1-DR（数据缓冲寄存器）" class="headerlink" title="1.DR（数据缓冲寄存器）"></a>1.DR（数据缓冲寄存器）</h4><p>暂时存放运算器与外界传送的数据</p><h4 id="2-通用寄存器"><a href="#2-通用寄存器" class="headerlink" title="2.通用寄存器"></a>2.通用寄存器</h4><p>暂时存放ALU运算的数据或结果</p><h4 id="3-PSW（状态条件寄存器）"><a href="#3-PSW（状态条件寄存器）" class="headerlink" title="3.PSW（状态条件寄存器）"></a>3.PSW（状态条件寄存器）</h4><p>C：进位标志</p><p>V：溢出标志</p><p>Z：零标志</p><p>W：符号标志</p><h4 id="4-AR（数据地址寄存器）"><a href="#4-AR（数据地址寄存器）" class="headerlink" title="4.AR（数据地址寄存器）"></a>4.AR（数据地址寄存器）</h4><p>保存当前CPU所访问数据的内存单元地址</p><h4 id="5-PC（程序计数器）"><a href="#5-PC（程序计数器）" class="headerlink" title="5.PC（程序计数器）"></a>5.PC（程序计数器）</h4><p>始终存放下一条指令的地址，对应于指令Cache的访问</p><h4 id="6-IR（指令寄存器）"><a href="#6-IR（指令寄存器）" class="headerlink" title="6.IR（指令寄存器）"></a>6.IR（指令寄存器）</h4><p>保存当前正在执行的一条指令</p><p>其对应的操作码字段直接作为指令译码器的输入</p><h3 id="操作控制器与时序产生器"><a href="#操作控制器与时序产生器" class="headerlink" title="操作控制器与时序产生器"></a>操作控制器与时序产生器</h3><p><strong>数据通路</strong>：两个部件之间传送信息的通路</p><h4 id="操作控制器"><a href="#操作控制器" class="headerlink" title="操作控制器"></a>操作控制器</h4><p>根据指令操作码和时序信号，产生各种操作控制信号；</p><p>建立正确的数据通路，从而完成指令的执行</p><h4 id="分类（根据设计方法）"><a href="#分类（根据设计方法）" class="headerlink" title="分类（根据设计方法）"></a>分类（根据设计方法）</h4><p>1.硬布线控制器：采用时序逻辑技术实现</p><p>2.微程序控制器：采用存储逻辑实现</p><p>3.两种方式的结合</p><h2 id="5-2指令周期"><a href="#5-2指令周期" class="headerlink" title="5.2指令周期"></a>5.2指令周期</h2><h3 id="指令周期的基本概念"><a href="#指令周期的基本概念" class="headerlink" title="指令周期的基本概念"></a>指令周期的基本概念</h3><p>CPU执行程序是一个“取指令—执行指令” 的循环过程</p><p>对于一个指令周期来说，我们取出一条指令，然后执行它，至少需要两个 CPU 周期。取出指令至少需要一个 CPU 周期，执行至少也需要一个 CPU 周期，复杂的指令则需要更多的 CPU 周期。</p><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>CPU从内存中取出一条指令，并执行完毕的时间总和</p><h4 id="CPU周期"><a href="#CPU周期" class="headerlink" title="CPU周期"></a>CPU周期</h4><p>又称为机器周期，一般为从内存读取一条指令字的最短时间</p><p>一条指令执行过程被划分为若干阶段（比如取指、译码、执行等），每一阶段完成所需时间。一般情况下一个CPU周期是若干时钟周期之和。</p><h4 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h4><p>也叫做节拍脉冲或T周期，是计算机工作的基本时间单位</p><h4 id="MOV-R0-R1-指令的指令周期"><a href="#MOV-R0-R1-指令的指令周期" class="headerlink" title="MOV R0,R1 指令的指令周期"></a>MOV R0,R1 指令的指令周期</h4><p>它需要两个CPU周期</p><h5 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h5><p>1.PC–&gt;ABUS(地址总线)–&gt;指令Cache，译码并启动   <strong>PC读，指令Cache启动</strong></p><p>2.指令Cache–&gt;IR    <strong>指令Cache读，IR写</strong></p><p>3.PC+1–&gt;PC，为下条指令做准备  <strong>PC增加</strong></p><p>4.IR中的操作码被译码或测试，CPU识别出是指令MOV</p><h5 id="执行指令周期"><a href="#执行指令周期" class="headerlink" title="执行指令周期"></a>执行指令周期</h5><p>1.R1–&gt;ALU ，R1中数据通过ALU传送    <strong>R1读，ALU传送控制</strong></p><p>2.ALU–&gt;DBUS（<strong>地址总线</strong>）–&gt;DR–&gt;R0  <strong>ALU输出，DR锁存，R0写</strong></p><h4 id="LAD-R1-6-指令周期"><a href="#LAD-R1-6-指令周期" class="headerlink" title="LAD R1,6 指令周期"></a>LAD R1,6 指令周期</h4><h5 id="取指周期-1"><a href="#取指周期-1" class="headerlink" title="取指周期"></a>取指周期</h5><p>与MOV一致</p><h5 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h5><p>IR–&gt;DBUS–&gt;AR  I<strong>R读，AR锁存</strong></p><p>AR–&gt;ABUS–&gt;数据Cache，译码并启动    <strong>数据Cache启动</strong></p><p>数据Cache –&gt;DBUS–&gt;DR–&gt;R1  <strong>数据Cache读，DR锁存，R1写</strong></p><p>  执行周期需要两个CPU周期的原因：源操作数的地址和源操作数都需要经过DBUS传送</p><h4 id="ADD-R1-R2指令周期"><a href="#ADD-R1-R2指令周期" class="headerlink" title="ADD R1,R2指令周期"></a>ADD R1,R2指令周期</h4><h5 id="取指周期-2"><a href="#取指周期-2" class="headerlink" title="取指周期"></a>取指周期</h5><p>同MOV</p><h5 id="执行周期-1"><a href="#执行周期-1" class="headerlink" title="执行周期"></a>执行周期</h5><p>R1、R2 –&gt; ALU  <strong>R1,R2读</strong></p><p>ALU做加运算，将两数相加  <strong>ALU加</strong></p><p>ALU –&gt;DBUS –&gt;DR –&gt;R2 <strong>ALU输出，DR锁存，R2写</strong></p><h4 id="STO-R2-R3-指令周期"><a href="#STO-R2-R3-指令周期" class="headerlink" title="STO R2 ,(R3)指令周期"></a>STO R2 ,(R3)指令周期</h4><h5 id="取指周期-3"><a href="#取指周期-3" class="headerlink" title="取指周期"></a>取指周期</h5><p>同MOV</p><h5 id="执行周期-2"><a href="#执行周期-2" class="headerlink" title="执行周期"></a>执行周期</h5><p>R3 –&gt;DBUS–&gt;AR 发出地址启动数据Cache <strong>R3读，AR锁存</strong></p><p>   该过程为间址周期</p><p>R2 –&gt; DBUS –&gt;数据Cache <strong>R2读，数据Cache写</strong></p><h4 id="方框语言表示指令周期"><a href="#方框语言表示指令周期" class="headerlink" title="方框语言表示指令周期"></a>方框语言表示指令周期</h4><p>1.方框</p><p>代表一个CPU周期</p><p>2.菱形</p><p>通常用来表示某种判别或测试</p><p>3.~</p><p>表示一条指令已经执行完毕，转入公操作</p><p><img src="image4.png" alt="image4"></p><h2 id="5-3时序产生器和控制方式"><a href="#5-3时序产生器和控制方式" class="headerlink" title="5.3时序产生器和控制方式"></a>5.3时序产生器和控制方式</h2><h2 id="5-4微程序控制器"><a href="#5-4微程序控制器" class="headerlink" title="5.4微程序控制器"></a>5.4微程序控制器</h2><h3 id="微程序控制原理"><a href="#微程序控制原理" class="headerlink" title="微程序控制原理"></a>微程序控制原理</h3><h4 id="利用软件方法来设计硬件"><a href="#利用软件方法来设计硬件" class="headerlink" title="利用软件方法来设计硬件"></a>利用软件方法来设计硬件</h4><p>规整性、灵活性、可维护性等特点</p><p>广泛使用</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>把操作控制信号编成“微指令”</p><h4 id="微操作分类"><a href="#微操作分类" class="headerlink" title="微操作分类"></a>微操作分类</h4><p>相容性微操作：同时或者在同一个CPU周期可以并行执行的微操作</p><p>相斥性微操作：上面反之          </p><h4 id="微指令和微程序"><a href="#微指令和微程序" class="headerlink" title="微指令和微程序"></a>微指令和微程序</h4><p><strong>微指令</strong>一般包含操作控制和顺序控制</p><p>  <strong>操作控制</strong>：用于发出管理和指挥全机工作的控制信号</p><p>  <strong>顺序控制</strong>：用于决定产生下一条微指令的地址</p><p>所有的微指令都存放于控制存储器中，使用<strong>地址</strong>访问</p><p>微程序：</p><p>  能够实现一条机器指令功能的多条微指令序列</p><p>  每条机器指令都对应着一段微程序</p><h4 id="微程序控制器原理框图"><a href="#微程序控制器原理框图" class="headerlink" title="微程序控制器原理框图"></a>微程序控制器原理框图</h4><p><strong>控制存储器（CM</strong>）：存放实现指令系统所需要的全部微指令 —–<strong>主存储器（MM）</strong></p><p><strong>微指令寄存器：</strong>存放当前正在执行的一条微指令，由微地址寄存器和微命令寄存器构成</p><p>​微地址寄存器：决定要访问的下一条微指令的地址</p><p>​微命令寄存器：保存一条微指令的操作控制字段和判别测试字段的信息</p><p><strong>地址转移逻辑：</strong> 跳跃寻址微指令时，负责微地址的修改</p><p>​</p><h3 id="微程序设计技术"><a href="#微程序设计技术" class="headerlink" title="微程序设计技术"></a>微程序设计技术</h3><h4 id="微命令编码"><a href="#微命令编码" class="headerlink" title="微命令编码"></a>微命令编码</h4><h5 id="直接表示法："><a href="#直接表示法：" class="headerlink" title="直接表示法："></a>直接表示法：</h5><p>操作控制字段中每一位代表一个微命令，</p><p>简单直观，执行快</p><p>容量较大</p><h5 id="编码表示法："><a href="#编码表示法：" class="headerlink" title="编码表示法："></a>编码表示法：</h5><p>将微指令操作控制字段划分为若干个子字段，每个子字段的所有微指令进行统一编码，每个子字段的不同编码表示不同的微命令</p><p><strong>遵循原则</strong> ：相斥的微命令划分在同一个字段，每个子字段应该留出一个<strong>空操作状态</strong>，每个子字段所定义的微指令不宜太多</p><h4 id="微地址的形成方法"><a href="#微地址的形成方法" class="headerlink" title="微地址的形成方法"></a>微地址的形成方法</h4><p><strong>微程序的入口地址：</strong></p><p>  微程序的第一条微指令所在控存单元的地址；</p><p>​      机器执行周期的第一条微指令</p><p><strong>现行微指令</strong> ：正在执行的微指令，因此地址叫做现行微地址</p><p><strong>后继微指令</strong> ：下一条要执行的微指令</p><h4 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h4><p>​                                                                                                                                                                                                                                                                                              </p><h2 id="5-5硬连线控制器"><a href="#5-5硬连线控制器" class="headerlink" title="5.5硬连线控制器"></a>5.5硬连线控制器</h2><p>硬布线控制器是由门电路和触发器构成的复杂树形网络，<strong>速度比微程序快</strong>，但是一旦构成，<strong>无法增加新的控制功能</strong></p><h3 id="微命令和微操作"><a href="#微命令和微操作" class="headerlink" title="微命令和微操作"></a>微命令和微操作</h3><h4 id="控制部件和执行部件的联系"><a href="#控制部件和执行部件的联系" class="headerlink" title="控制部件和执行部件的联系"></a>控制部件和执行部件的联系</h4><p>控制部件向执行部件发出控制信号；</p><p>执行部件向控制部件返回状态信息</p><h4 id="微命令"><a href="#微命令" class="headerlink" title="微命令"></a>微命令</h4><p>控制部件通过控制线向执行部件发出的各种控制命令</p><h4 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h4><p>执行部件接受微命令后所执行的操作</p><h4 id="状态测试"><a href="#状态测试" class="headerlink" title="状态测试"></a>状态测试</h4><p>执行部件通过反馈线向控制部件反映当前操作状态，以使控制部件决定下一步的微命令</p><p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%5Cimage5.png" alt="image5"></p><h2 id="5-6流水CPU"><a href="#5-6流水CPU" class="headerlink" title="5.6流水CPU"></a>5.6流水CPU</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客美化</title>
      <link href="/2023/05/07/Blog/"/>
      <url>/2023/05/07/Blog/</url>
      
        <content type="html"><![CDATA[<h1 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h1><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>博客图片无法显示</p><p>方法如下：</p><p>1.根目录下打开 <strong>git bash here</strong></p><p>2.输入命令：<strong>npm install hexo-asset-image –save</strong></p><p>3.在博客的根目录下找：<strong>node_modules<code>--&gt;</code>hexo-asset-image<code>--&gt;</code>index.js</strong></p><p>在第55行把如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, src);</span><br></pre></td></tr></table></figure><p>然后保存</p><p>4.把_config.yml中的post_asset_folder: false   改成  post_asset_folder: true</p><p>当你创建一个md文件时，会自动生成一个与你的文章同名的文件夹，可以用来存放图片</p><p>5.图片地址的表示</p><p><img src="image4.png" alt="image4"></p><p>[]里面的是图片的描述，加载不出来的时候会显示这个</p><p>后面()里面的是地址，图片是放在同名的文件夹下的，直接就是图片名字，没有加其他的地址</p><p>当然也可以加上地址（我更习惯加上地址，不加的话Typora不能预览）</p><p><img src="Blog%5Cimage5.png" alt="image5"></p><h1 id="完善博客"><a href="#完善博客" class="headerlink" title="完善博客"></a>完善博客</h1><h2 id="添加评论（valien）"><a href="#添加评论（valien）" class="headerlink" title="添加评论（valien）"></a>添加评论（valien）</h2><p>1.创建<a href="https://www.leancloud.cn/">LeanCloud</a>账号，用国内版的，但是你的域名要备案，如果没有备案的话下面就不用看了，原本国际版是可以用的但是现在好像不能了。</p><p>2.创建应用，随便输入名称</p><p><img src="image1.png" alt="image1"></p><p>3.点击设置，在应用凭证那里有AppID 和 AppKey 复制下来留着用</p><p>4.更改配置，在_config.butterfly.yml文件里找到comments修改</p><p><img src="image2.png" alt="image2"></p><p>然后再在该文件下找valine，修改</p><p><img src="image3.png" alt="image3"></p><p>之后再hexo三部曲。</p><p>最后，我自己没弄好评论，我的域名没有备案，我原本是想用leanCloud的国际版的，但是也不行，搜了发现国际版不支持了。so就先这样</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/04/hello-world/"/>
      <url>/2023/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
